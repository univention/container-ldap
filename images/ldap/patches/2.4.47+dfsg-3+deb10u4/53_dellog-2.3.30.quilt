diff -Nuar -x '*.orig' openldap-2.4.31.orig/configure openldap-2.4.31/configure
--- openldap-2.4.31.orig/configure	2012-07-19 14:41:49.303915245 +0200
+++ openldap-2.4.31/configure	2012-07-19 14:44:33.836915958 +0200
@@ -792,6 +792,7 @@
 BUILD_RETCODE
 BUILD_REFINT
 BUILD_PROXYCACHE
+BUILD_DELLOG
 BUILD_PPOLICY
 BUILD_MEMBEROF
 BUILD_LASTMOD
@@ -1700,6 +1701,7 @@
     --enable-memberof	  Reverse Group Membership overlay no|yes|mod [no]
     --enable-ppolicy	  Password Policy overlay no|yes|mod [no]
     --enable-proxycache	  Proxy Cache overlay no|yes|mod [no]
+    --enable-dellog	  Delete Log overlay no|yes|mod no
     --enable-refint	  Referential Integrity overlay no|yes|mod [no]
     --enable-retcode	  Return Code testing overlay no|yes|mod [no]
     --enable-rwm       	  Rewrite/Remap overlay no|yes|mod [no]
@@ -3790,6 +3792,28 @@
 fi
 # end --with-odbc
 
+# OpenLDAP --enable-dellog
+	# Check whether --enable-dellog or --disable-dellog was given.
+if test "${enable_dellog+set}" = set; then
+  enableval="$enable_dellog"
+
+	ol_arg=invalid
+	for ol_val in no yes mod ; do
+		if test "$enableval" = "$ol_val" ; then
+			ol_arg="$ol_val"
+		fi
+	done
+	if test "$ol_arg" = "invalid" ; then
+		{ { echo "$as_me:$LINENO: error: bad value $enableval for --enable-dellog" >&5
+echo "$as_me: error: bad value $enableval for --enable-dellog" >&2;}
+   { (exit 1); exit 1; }; }
+	fi
+	ol_enable_dellog="$ol_arg"
+
+else
+  	ol_enable_dellog="no"
+fi; # end --enable-dellog
+
 
 
 # Check whether --enable-xxslapdoptions was given.
@@ -4439,6 +4463,7 @@
 	memberof \
 	ppolicy \
 	proxycache \
+	dellog \
 	refint \
 	retcode \
 	rwm \
@@ -5152,6 +5177,7 @@
 BUILD_MEMBEROF=no
 BUILD_PPOLICY=no
 BUILD_PROXYCACHE=no
+BUILD_DELLOG=no
 BUILD_REFINT=no
 BUILD_RETCODE=no
 BUILD_RWM=no
@@ -24630,6 +24656,21 @@
 
 fi
 
+if test "$ol_enable_dellog" != no ; then
+	BUILD_DELLOG=$ol_enable_dellog
+	if test "$ol_enable_dellog" = mod ; then
+		MFLAG=SLAPD_MOD_DYNAMIC
+		SLAPD_DYNAMIC_OVERLAYS="$SLAPD_DYNAMIC_OVERLAYS dellog.la"
+	else
+		MFLAG=SLAPD_MOD_STATIC
+	fi
+
+cat >>confdefs.h <<_ACEOF
+#define SLAPD_OVER_DELLOG $MFLAG
+_ACEOF
+
+fi
+
 if test "$ol_enable_refint" != no ; then
 	BUILD_REFINT=$ol_enable_refint
 	if test "$ol_enable_refint" = mod ; then
diff -Nuar -x '*.orig' openldap-2.4.31.orig/configure.in openldap-2.4.31/configure.in
--- openldap-2.4.31.orig/configure.in	2012-07-19 14:41:49.308920086 +0200
+++ openldap-2.4.31/configure.in	2012-07-19 14:44:33.840919378 +0200
@@ -347,6 +347,7 @@
 	memberof \
 	ppolicy \
 	proxycache \
+	dellog \
 	refint \
 	retcode \
 	rwm \
@@ -401,6 +402,8 @@
 	no, [no yes mod], ol_enable_overlays)
 OL_ARG_ENABLE(unique,[    --enable-unique       Attribute Uniqueness overlay],
 	no, [no yes mod], ol_enable_overlays)
+OL_ARG_ENABLE(dellog,[    --enable-dellog	  Delete Log overlay no|yes|mod], no,
+	[no yes mod])
 OL_ARG_ENABLE(valsort,[    --enable-valsort      Value Sorting overlay],
 	no, [no yes mod], ol_enable_overlays)
 OL_ARG_ENABLE(translog,[    --enable-translog      Transactions Log overlay],
@@ -564,6 +567,7 @@
 BUILD_MEMBEROF=no
 BUILD_PPOLICY=no
 BUILD_PROXYCACHE=no
+BUILD_DELLOG=no
 BUILD_REFINT=no
 BUILD_RETCODE=no
 BUILD_RWM=no
@@ -2938,6 +2942,17 @@
 	AC_DEFINE_UNQUOTED(SLAPD_OVER_PROXYCACHE,$MFLAG,[define for Proxy Cache overlay])
 fi
 
+if test "$ol_enable_dellog" != no ; then
+	BUILD_DELLOG=$ol_enable_dellog
+	if test "$ol_enable_dellog" = mod ; then
+		MFLAG=SLAPD_MOD_DYNAMIC
+		SLAPD_DYNAMIC_OVERLAYS="$SLAPD_DYNAMIC_OVERLAYS dellog.la"
+	else
+		MFLAG=SLAPD_MOD_STATIC
+	fi
+	AC_DEFINE_UNQUOTED(SLAPD_OVER_DELLOG,$MFLAG,[define for Delete Log overlay])
+fi
+
 if test "$ol_enable_refint" != no ; then
 	BUILD_REFINT=$ol_enable_refint
 	if test "$ol_enable_refint" = mod ; then
@@ -3127,6 +3142,7 @@
   AC_SUBST(BUILD_MEMBEROF)
   AC_SUBST(BUILD_PPOLICY)
   AC_SUBST(BUILD_PROXYCACHE)
+  AC_SUBST(BUILD_DELLOG)
   AC_SUBST(BUILD_REFINT)
   AC_SUBST(BUILD_RETCODE)
   AC_SUBST(BUILD_RWM)
diff -Nuar -x '*.orig' openldap-2.4.31.orig/include/portable.hin openldap-2.4.31/include/portable.hin
--- openldap-2.4.31.orig/include/portable.hin	2012-07-19 14:41:49.308920086 +0200
+++ openldap-2.4.31/include/portable.hin	2012-07-19 14:44:33.840919378 +0200
@@ -63,6 +63,9 @@
 /* define if sys_errlist is not declared in stdio.h or errno.h */
 #undef DECL_SYS_ERRLIST
 
+/* define for Delete Log overlay */
+#undef SLAPD_OVER_DELLOG
+
 /* define to enable rewriting in back-ldap and back-meta */
 #undef ENABLE_REWRITE
 
diff -Nuar -x '*.orig' openldap-2.4.31.orig/servers/slapd/overlays/dellog.c openldap-2.4.31/servers/slapd/overlays/dellog.c
--- openldap-2.4.31.orig/servers/slapd/overlays/dellog.c	1970-01-01 01:00:00.000000000 +0100
+++ openldap-2.4.31/servers/slapd/overlays/dellog.c	2012-07-19 14:44:33.840919378 +0200
@@ -0,0 +1,338 @@
+/* dellog.c - Slapd overlay module logging bindDN and time of delete operations */
+
+#include "portable.h"
+
+#ifdef SLAPD_OVER_DELLOG
+
+#define MAX_PATH_LEN 4096
+
+#include <stdio.h>
+#include <unistd.h>
+#include <ac/string.h>
+#include <ac/socket.h>
+#include <errno.h>
+
+#include "slap.h"
+#include "lutil.h"
+
+//--- Stuff from slap.h:
+// bind DN: berval op->o_dn
+// 	"o_dn is assigned from conn->c_dn, and is in turn normalised into o_ndn (see connection_op_activate() in servers/slapd/connection.c)"
+// DN of target of request: berval op->o_req_dn
+// time of request: time_t op->o_time
+//
+// generation of a unique ID for the filename:
+//   The get_last_id code from translog allows an unset ID, that's why the slap_op_time from slapd 2.3
+//   is emloyed for this purpose.
+//   slapd v. 2.3 sets o_time and o_tincr in operation.c by slap_op_time(), while 2.2 only sets o_time,
+//   which again is not unique. Thus the slap_op_time and slap_timestamp code have been copied from 2.3.
+
+typedef struct dellog_data {
+	ldap_pvt_thread_mutex_t mutex;
+	char *logdirname;
+	int len_logdirname;
+} dellog_data;
+
+/* from slapd 2.3 modify.c */
+static ldap_pvt_thread_mutex_t  dellog_gmtime_mutex;
+static time_t last_time;
+static int last_incr;
+
+/* Enter with bv->bv_len = sizeof buffer, returns with
+ * actual length of string
+ */
+void slap_timestamp( time_t *tm, struct berval *bv )
+{
+        struct tm *ltm;
+#ifdef HAVE_GMTIME_R
+        struct tm ltm_buf;
+
+        ltm = gmtime_r( tm, &ltm_buf );
+#else
+        ldap_pvt_thread_mutex_lock( &dellog_gmtime_mutex );
+        ltm = gmtime( tm );
+#endif
+
+        bv->bv_len = lutil_gentime( bv->bv_val, bv->bv_len, ltm );
+
+#ifndef HAVE_GMTIME_R
+        ldap_pvt_thread_mutex_unlock( &dellog_gmtime_mutex );
+#endif
+}
+
+/* from slapd 2.3 operation.c:slap_op_time() */
+static ldap_pvt_thread_mutex_t  dellog_mutex;
+
+static void dellog_extendedTime(time_t *t, int *nop)
+{
+        *t = slap_get_time();
+        ldap_pvt_thread_mutex_lock( &dellog_mutex );
+        if ( *t == last_time ) {
+                *nop = ++last_incr;
+        } else {
+                last_time = *t;
+                last_incr = 0;
+                *nop = 0;
+        }
+        ldap_pvt_thread_mutex_unlock( &dellog_mutex );
+}
+
+static long get_last_id( Operation *op )
+{
+	/* Get the last used Transaction ID from Transaction-Log file
+	 * Returns:
+	 * 	-1 und errors
+	 * 	0 if Transaction-Log file is empty
+	 * 	last Transaction ID if Transaction-Log file is nonempty
+	 */
+	FILE *f;
+	int i = 2;
+	char c;
+	long id = -1;
+	
+	Debug( LDAP_DEBUG_TRACE, "OVER: get_last_id\n", 0, 0, 0);
+
+	/* if the file /var/lib/univention-ldap/last_id exists, we read the last id
+	 * from this file
+	 */
+	f = fopen( "/var/lib/univention-ldap/last_id", "r" );
+
+	if ( f != NULL ) {
+		fscanf( f, "%ld", & id );
+		fclose( f );
+
+		return id;
+	}
+
+	if ( ( f = fopen( "/var/lib/univention-ldap/notify/transaction", "r" ) ) == NULL ) {
+		Debug( LDAP_DEBUG_ANY, "OVER: unable to open transaction file\n", 0, 0, 0);
+		id = -1;
+		return id;
+	}
+
+	do {
+		i++;
+		fseek( f, -i, SEEK_END);
+		c = fgetc ( f ) ;
+	} while ( c != '\n' && c != -1 && c != 255 && ftell(f) != 1);
+
+	if ( c == -1 || c == 255 ) {
+		/* emty file */
+		id = 0;
+
+	} else if ( ftell(f) == 1) {
+		/* only one entry */
+		fseek( f, 0, SEEK_SET);
+#ifdef WITH_STAMP
+		fseek(f, 24, SEEK_CUR);
+#endif
+		fscanf( f, "%ld", &id);
+
+	} else {
+#ifdef WITH_STAMP
+		fseek(f, 24, SEEK_CUR);
+#endif
+		fscanf( f, "%ld", &id);
+	}
+
+	fclose(f);
+	return id;
+}
+
+static int dellog_response ( Operation *op, SlapReply *rs )
+{
+	/* Handel delete responses from database backend
+	 * Returns:
+	 * 	SLAP_CB_CONTINUE to pass to next overlay
+	 */
+	FILE *file;
+	long lastid = -1;
+
+	/* If the current response is what we're looking for */
+	if ( rs->sr_err == LDAP_SUCCESS ) {
+	if ( op->o_tag == LDAP_REQ_DELETE || op->o_tag == LDAP_REQ_MODDN ) {
+
+		slap_overinst *on = (slap_overinst *)op->o_bd->bd_info;
+		dellog_data *state = on->on_bi.bi_private;
+
+		/* Check if we've been configured */
+		if ( !state || !state->logdirname ) {
+			Debug( LDAP_DEBUG_TRACE|LDAP_DEBUG_NONE, "OVER: Dellog logdirname not initialized\n", 0, 0, 0 );
+			return SLAP_CB_CONTINUE;
+		}
+
+		time_t d_time;
+		int d_tincr;
+		dellog_extendedTime(&d_time, &d_tincr);
+		/* generate timestamp in slapd format */
+		struct berval timestamp;
+		timestamp.bv_len = LDAP_LUTIL_GENTIME_BUFSIZE;
+		char timestampbuf[ timestamp.bv_len + 1 ];
+		timestamp.bv_val = timestampbuf;
+		/* modifyTimestamp markup: */
+		slap_timestamp( &d_time, &timestamp );
+		timestampbuf[sizeof(timestampbuf)-1] = '\0'; // finish the string
+
+		struct berval ldapUniqueTimestamp;
+		ldapUniqueTimestamp.bv_len = timestamp.bv_len + 7;
+		char extendedTimestampbuf[ ldapUniqueTimestamp.bv_len + 1 ];
+		ldapUniqueTimestamp.bv_val = extendedTimestampbuf;
+		strncpy( extendedTimestampbuf, timestamp.bv_val, timestamp.bv_len );
+		sprintf( ldapUniqueTimestamp.bv_val + timestamp.bv_len-1, ".%06dZ", d_tincr );
+		// ^^^ "timestamp.bv_len-1" : overwrite the 'Z' character
+		int size_extendedTimestampbuf = sizeof(extendedTimestampbuf);
+		extendedTimestampbuf[size_extendedTimestampbuf - 1] = '\0'; // finish the string
+
+		ldap_pvt_thread_mutex_lock(&state->mutex);
+
+		char filename[state->len_logdirname + size_extendedTimestampbuf];
+		strncpy( filename, state->logdirname, state->len_logdirname);
+		strncpy( filename + state->len_logdirname, extendedTimestampbuf, size_extendedTimestampbuf);
+
+		char type;
+		switch (op->o_tag) {
+			case LDAP_REQ_DELETE:
+				type = 'd';
+				break;
+			case LDAP_REQ_MODDN:
+				type = 'r';
+				break;
+		}
+
+		/* unique filename, no lock */
+		if((file = fopen(filename, "w")) == NULL) {
+			Debug( LDAP_DEBUG_ANY, "OVER: Dellog Could not open logfile\n", 0, 0, 0 );
+			
+			ldap_pvt_thread_mutex_unlock(&state->mutex);
+			return SLAP_CB_CONTINUE;
+		}
+
+		//fprintf(file, "%s\n%s\n%s\n", timestamp.bv_val, op->o_req_dn.bv_val, op->o_dn.bv_val);
+
+		lastid = get_last_id(op);
+		if ( lastid > -1 ) {
+			fprintf(file, "%s\n%ld\n%s\n%s\n%c\n", timestamp.bv_val, ++lastid, op->o_req_dn.bv_val, op->o_dn.bv_val, type);
+		} else {
+			Debug( LDAP_DEBUG_ANY, "OVER: Dellog could not find last ID, seems to be: \"%ld\"\n", lastid, 0, 0 );
+			fprintf(file, "%s\n<TransID>\n%s\n%s\n%c\n", timestamp.bv_val, op->o_req_dn.bv_val, op->o_dn.bv_val, type);
+		}
+
+		fclose(file);
+
+		ldap_pvt_thread_mutex_unlock(&state->mutex);
+	}
+	}
+
+	return SLAP_CB_CONTINUE;
+}
+
+static int dellog_db_config ( BackendDB *be, const char *fname, int lineno, int argc, char **argv )
+{
+	Debug( LDAP_DEBUG_CONFIG|LDAP_DEBUG_TRACE, "OVER: Dellog db_config\n", 0, 0, 0 );
+	
+	slap_overinst *on = (slap_overinst *) be->bd_info;
+	dellog_data *state = on->on_bi.bi_private;
+	
+	/* log file */
+	if ( strcasecmp( argv[0], "dellog" ) == 0 ) {
+		if ( argc < 2 ) {
+			Debug( LDAP_DEBUG_CONFIG|LDAP_DEBUG_NONE, "%s: line %d: missing filename in \"dellog <filename>\" line\n", fname, lineno, 0 );
+			return(1);
+		}
+
+		errno = 0;
+		if (opendir(argv[1]) == NULL) {
+			Debug( LDAP_DEBUG_CONFIG|LDAP_DEBUG_NONE, "OVER: Dellog cannot access directory \"%s\": %s\n", ch_strdup( argv[1] ), strerror(errno), 0 );
+			return(1);
+		} else {
+			Debug( LDAP_DEBUG_CONFIG, "OVER: Dellog using directory \"%s\"\n", ch_strdup( argv[1] ), 0, 0 );
+		}
+
+
+		/* save dirname in dellog_data */
+		int len = strlen( argv[1] );
+		char dirseperator = '/';
+		if(argv[1][len-1] == dirseperator) {
+			state->len_logdirname = len;
+			state->logdirname = ch_strdup( argv[1] );
+		} else {
+			state->len_logdirname = len+1;
+			state->logdirname = ch_malloc( len+2 );
+			strncpy( state->logdirname, argv[1], len );
+			state->logdirname[len] = dirseperator;
+			state->logdirname[len+1] = '\0';
+		}
+
+		return 0;
+	} else {
+		return SLAP_CONF_UNKNOWN;
+	}
+	return 0;
+}
+
+static int dellog_db_close ( BackendDB *be )
+{
+	Debug( LDAP_DEBUG_TRACE, "OVER: Dellog db_close\n", 0, 0, 0 );
+	
+	slap_overinst *on = (slap_overinst *)be->bd_info;
+	dellog_data *state = on->on_bi.bi_private;
+
+	free( state->logdirname ); state->logdirname = NULL;
+	return 0;
+}
+
+static int dellog_db_init ( BackendDB *be )
+{
+	Debug( LDAP_DEBUG_TRACE, "OVER: Dellog db_init\n", 0, 0, 0 );
+	
+	slap_overinst *on = (slap_overinst *)be->bd_info;
+	dellog_data *state = ch_calloc(1, sizeof(dellog_data));
+
+	on->on_bi.bi_private = state;
+	ldap_pvt_thread_mutex_init( &state->mutex );
+	return 0;
+}
+
+static int dellog_db_destroy ( BackendDB *be )
+{
+	Debug( LDAP_DEBUG_TRACE, "OVER: Dellog db_destroy\n", 0, 0, 0 );
+	
+	slap_overinst *on = (slap_overinst *)be->bd_info;
+	dellog_data *state = on->on_bi.bi_private;
+
+	ldap_pvt_thread_mutex_destroy( &state->mutex );
+	free( state ); state = NULL;
+	return 0;
+}
+
+static slap_overinst dellog;
+
+/* This overlay is set up for dynamic loading via moduleload. For static
+ * configuration, you'll need to arrange for the slap_overinst to be
+ * initialized and registered by some other function inside slapd.
+ */
+
+int dellog_init ()
+{
+	dellog.on_bi.bi_type = "dellog";
+
+	dellog.on_bi.bi_db_init = dellog_db_init;
+	dellog.on_bi.bi_db_destroy = dellog_db_destroy;
+
+	dellog.on_bi.bi_db_config = dellog_db_config;
+	dellog.on_bi.bi_db_close = dellog_db_close;
+
+	//dellog.on_bi.bi_op_delete = dellog_op_delete;
+	dellog.on_response = dellog_response;
+
+	return overlay_register( &dellog );
+}
+
+#if SLAPD_OVER_DELLOG == SLAPD_MOD_DYNAMIC
+int init_module ( int argc, char *argv[] )
+{
+	return dellog_init();
+}
+#endif
+
+#endif /* defined(SLAPD_OVER_DELLOG) */
diff -Nuar -x '*.orig' openldap-2.4.31.orig/servers/slapd/overlays/Makefile.in openldap-2.4.31/servers/slapd/overlays/Makefile.in
--- openldap-2.4.31.orig/servers/slapd/overlays/Makefile.in	2012-07-19 14:41:49.308920086 +0200
+++ openldap-2.4.31/servers/slapd/overlays/Makefile.in	2012-07-19 14:44:33.844916988 +0200
@@ -18,6 +18,7 @@
 	auditlog.c \
 	constraint.c \
 	dds.c \
+ 	dellog.o \
 	deref.c \
 	dyngroup.c \
 	dynlist.c \
@@ -37,6 +38,7 @@
 	translog.c
 OBJS = statover.o \
 	@SLAPD_STATIC_OVERLAYS@ \
+ 	dellog.o \
 	overlays.o
 
 # Add here the objs that are needed by overlays, but do not make it
@@ -129,6 +131,12 @@
 translog.la : translog.lo
 	$(LTLINK_MOD) -module -o $@ translog.lo version.lo $(LINK_LIBS)
 
+dellog.la : dellog.lo $(@PLAT@_LINK_LIBS)
+	$(LTLINK_MOD) -module -o $@ dellog.lo version.lo $(LINK_LIBS)
+
+dellog.la : dellog.lo $(@PLAT@_LINK_LIBS)
+	$(LTLINK_MOD) -module -o $@ dellog.lo version.lo $(LINK_LIBS)
+
 install-local:	$(PROGRAMS)
 	@if test -n "$?" ; then \
 		$(MKDIR) $(DESTDIR)$(moduledir); \
