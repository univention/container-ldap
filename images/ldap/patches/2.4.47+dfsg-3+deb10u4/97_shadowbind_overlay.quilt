Bug #36215 - deny posix logins if user password expiration date has been reached

diff -Nur openldap-2.4.42+dfsg.o/contrib/slapd-modules/shadowbind/Makefile openldap-2.4.42+dfsg/contrib/slapd-modules/shadowbind/Makefile
--- openldap-2.4.42+dfsg.o/contrib/slapd-modules/shadowbind/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ openldap-2.4.42+dfsg/contrib/slapd-modules/shadowbind/Makefile	2016-08-31 20:10:56.871816000 +0200
@@ -0,0 +1,89 @@
+# Copyright 2016 Univention GmbH
+#
+# http://www.univention.de/
+#
+# All rights reserved.
+#
+# The source code of this program is made available
+# under the terms of the GNU Affero General Public License version 3
+# (GNU AGPL V3) as published by the Free Software Foundation.
+#
+# Binary versions of this program provided by Univention to you as
+# well as other copyrighted, protected or trademarked materials like
+# Logos, graphics, fonts, specific documentations and configurations,
+# cryptographic keys etc. are subject to a license agreement between
+# you and Univention and not subject to the GNU AGPL V3.
+#
+# In the case you use this program under the terms of the GNU AGPL V3,
+# the program is provided in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU Affero General Public License for more details.
+#
+# You should have received a copy of the GNU Affero General Public
+# License with the Debian GNU/Linux or Univention distribution in file
+# /usr/share/common-licenses/AGPL-3; if not, see
+# <http://www.gnu.org/licenses/>.
+
+# This work has been derived from parts of OpenLDAP Software <http://www.openldap.org/>.
+#
+# Copyright 1998-2011 The OpenLDAP Foundation.
+# Copyright 2004 Howard Chu, Symas Corp. All Rights Reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted only as authorized by the OpenLDAP
+# Public License.
+#
+# A copy of this license is available in the file LICENSE in the
+# top-level directory of the distribution or, alternatively, at
+# <http://www.OpenLDAP.org/license.html>.
+
+LDAP_SRC = ../../..
+LDAP_BUILD = $(LDAP_SRC)
+LDAP_INC = -I$(LDAP_BUILD)/include -I$(LDAP_SRC)/include -I$(LDAP_SRC)/servers/slapd
+LDAP_LIB = $(LDAP_BUILD)/libraries/libldap_r/libldap_r.la \
+	$(LDAP_BUILD)/libraries/liblber/liblber.la
+
+LIBTOOL = $(LDAP_BUILD)/libtool
+INSTALL = /usr/bin/install
+CC = gcc
+OPT = -g -O2 -Wall
+DEFS = -DSLAPD_OVER_SHADOWBIND=SLAPD_MOD_DYNAMIC
+INCS = $(LDAP_INC)
+LIBS = $(LDAP_LIB)
+
+PROGRAMS = shadowbind.la
+LTVER = 0:0:0
+
+prefix=/usr/local
+exec_prefix=$(prefix)
+ldap_subdir=/openldap
+
+libdir=$(exec_prefix)/lib
+libexecdir=$(exec_prefix)/libexec
+moduledir = $(libexecdir)$(ldap_subdir)
+
+.SUFFIXES: .c .o .lo
+
+.c.lo:
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(CPPFLAGS) $(DEFS) $(INCS) -c $<
+
+all: $(PROGRAMS)
+
+shadowbind.la:	shadowbind.lo
+	$(LIBTOOL) --mode=link $(CC) $(LDFLAGS) -version-info $(LTVER) \
+	-rpath $(moduledir) -module -o $@ $? $(LIBS)
+
+clean:
+	rm -rf *.o *.lo *.la .libs
+
+install: install-lib FORCE
+
+install-lib: $(PROGRAMS)
+	mkdir -p $(DESTDIR)$(moduledir)
+	for p in $(PROGRAMS) ; do \
+		$(LIBTOOL) --mode=install cp $$p $(DESTDIR)$(moduledir) ; \
+	done
+
+FORCE:
+
diff -Nur openldap-2.4.42+dfsg.o/contrib/slapd-modules/shadowbind/shadowbind.c openldap-2.4.42+dfsg/contrib/slapd-modules/shadowbind/shadowbind.c
--- openldap-2.4.42+dfsg.o/contrib/slapd-modules/shadowbind/shadowbind.c	1970-01-01 01:00:00.000000000 +0100
+++ openldap-2.4.42+dfsg/contrib/slapd-modules/shadowbind/shadowbind.c	2016-08-31 20:10:52.747816000 +0200
@@ -0,0 +1,358 @@
+/* shadowbind.c - overlay to deny login based shadow settings */
+
+/*
+ * Copyright 2016-2017 Univention GmbH
+ *
+ * http://www.univention.de/
+ *
+ * All rights reserved.
+ *
+ * The source code of this program is made available
+ * under the terms of the GNU Affero General Public License version 3
+ * (GNU AGPL V3) as published by the Free Software Foundation.
+ *
+ * Binary versions of this program provided by Univention to you as
+ * well as other copyrighted, protected or trademarked materials like
+ * Logos, graphics, fonts, specific documentations and configurations,
+ * cryptographic keys etc. are subject to a license agreement between
+ * you and Univention and not subject to the GNU AGPL V3.
+ *
+ * In the case you use this program under the terms of the GNU AGPL V3,
+ * the program is provided in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public
+ * License with the Debian GNU/Linux or Univention distribution in file
+ * /usr/share/common-licenses/AGPL-3; if not, see
+ * <http://www.gnu.org/licenses/>.
+ */
+
+/* This work is part of OpenLDAP Software <http://www.openldap.org/>.
+ *
+ * Copyright 2006-2015 The OpenLDAP Foundation.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted only as authorized by the OpenLDAP
+ * Public License.
+ *
+ * A copy of this license is available in the file LICENSE in the
+ * top-level directory of the distribution or, alternatively, at
+ * <http://www.OpenLDAP.org/license.html>.
+ */
+
+#include "portable.h"
+
+#ifdef SLAPD_OVER_SHADOWBIND
+
+#include "slap.h"
+#include "lutil.h"
+#include "config.h"
+
+#include <stdio.h>
+#include <ac/string.h>
+#include <ac/socket.h>
+#include <time.h>
+
+#define SLAPD_SHADOW_MAX_ATTR "shadowMax"
+#define SLAPD_SHADOW_LAST_CHANGE_ATTR "shadowLastChange"
+#define SLAPD_SHADOW_EXPIRE_ATTR "shadowExpire"
+
+static AttributeDescription *attr_shadowMax;
+static AttributeDescription *attr_shadowLastChange;
+static AttributeDescription *attr_shadowExpire;
+
+static ObjectClass *oc_shadowAccount;
+
+typedef struct shadowbind_cfg {
+	Filter *ignore_filter;
+} shadowbind_cfg;
+
+typedef struct shadowbind_cb_data {
+        slap_overinst *on;
+} shadowbind_cb_data;
+
+/* dynamic config, postponed
+
+static ConfigDriver shadowbind_cfg_func;
+
+static ConfigTable shadowbind_cfg_attrs[] = {
+        { "shadowbind-ignore-filter", "filter", 2, 2, 0,
+          ARG_STRING|ARG_OFFSET,
+          (void *)offsetof(shadowbind_cfg, ignore_filter),
+          "( OLcfgOvAt:15.1 NAME 'olcShadowBindIgnoreFilter' "
+          "DESC 'Ignore filter for shadowbind overlay' "
+          "SYNTAX OMsDirectoryString )", NULL, NULL },
+        { NULL, NULL, 0, 0, 0, ARG_IGNORED }
+};
+
+static ConfigOCs shadowbind_cfg_ocs[] = {
+        { "( OLcfgOvOc:15.1 "
+          "NAME 'olcShadowBindConfig' "
+          "DESC 'ShadowBind configuration' "
+          "SUP olcOverlayConfig "
+          "MAY ( olcShadowBindIgnoreFilter ) )",
+          Cft_Overlay, shadowbindcfg },
+        { NULL, 0, NULL }
+};
+
+static int
+shadowbind_cfg_func( ConfigArgs *c )
+{
+	...
+}
+
+*/
+
+static int
+shadowbind_db_init( BackendDB *be )
+{
+	Debug( LDAP_DEBUG_TRACE, "shadowbind_db_init\n", 0, 0, 0 );
+
+	slap_overinst *on = (slap_overinst *)be->bd_info;
+	on->on_bi.bi_private = ch_calloc(1, sizeof(shadowbind_cfg));
+
+	return 0;
+}
+
+static int
+shadowbind_db_open( BackendDB *be )
+{
+
+	Debug( LDAP_DEBUG_TRACE, "shadowbind_db_open\n", 0, 0, 0 );
+
+	int rc = -1;
+	const char *err;
+
+	if ( oc_shadowAccount == NULL ) {
+		oc_shadowAccount = oc_find( "shadowAccount" );
+		if ( !oc_shadowAccount ) {
+			Debug( LDAP_DEBUG_ANY, "shadowbind_db_open: "
+				"unable to find \"shadowAccount\" objectClass.\n",
+				0, 0, 0 );
+			return rc;
+		}
+	}
+
+	if ( attr_shadowMax == NULL ) {
+		rc = slap_str2ad( SLAPD_SHADOW_MAX_ATTR, &attr_shadowMax, &err );
+		if ( rc != LDAP_SUCCESS ) {
+			Debug( LDAP_DEBUG_ANY, "shadowbind_db_open: "
+				"unable to find attribute=\"%s\": %s (%d)\n",
+				SLAPD_SHADOW_MAX_ATTR, err, rc );
+			return rc;
+		}
+	}
+	if (attr_shadowLastChange == NULL) {
+		rc = slap_str2ad( SLAPD_SHADOW_LAST_CHANGE_ATTR, &attr_shadowLastChange, &err );
+		if ( rc != LDAP_SUCCESS ) {
+			Debug( LDAP_DEBUG_ANY, "shadowbind_db_open: "
+				"unable to find attribute=\"%s\": %s (%d)\n",
+				SLAPD_SHADOW_LAST_CHANGE_ATTR, err, rc );
+			return rc;
+		}
+	}
+	if (attr_shadowExpire == NULL) {
+		rc = slap_str2ad( SLAPD_SHADOW_EXPIRE_ATTR, &attr_shadowExpire, &err );
+		if ( rc != LDAP_SUCCESS ) {
+			Debug( LDAP_DEBUG_ANY, "shadowbind_db_open: "
+				"unable to find attribute=\"%s\": %s (%d)\n",
+				SLAPD_SHADOW_EXPIRE_ATTR, err, rc );
+			return rc;
+		}
+	}
+
+	return 0;
+}
+
+static int
+shadowbind_db_destroy( BackendDB *be )
+{
+	Debug( LDAP_DEBUG_TRACE, "shadowbind_db_destroy\n", 0, 0, 0 );
+
+	slap_overinst *on = (slap_overinst *) be->bd_info;
+	shadowbind_cfg *cfg = on->on_bi.bi_private;
+
+	if ( cfg->ignore_filter )
+		filter_free(cfg->ignore_filter);
+	ch_free(cfg);
+
+	return 0;
+}
+
+static int
+shadowbind_bind_response ( Operation *op, SlapReply *rs )
+{
+	/* we're only interested if the bind was successful */
+	if ( rs->sr_err != LDAP_SUCCESS )
+		return SLAP_CB_CONTINUE;
+
+	Debug( LDAP_DEBUG_TRACE, "shadowbind_bind_response: dn %s\n", op->o_req_ndn.bv_val, 0, 0 );
+
+	Entry *e;
+	Attribute *a;
+	int ret = SLAP_CB_CONTINUE;
+	time_t now = 0;
+
+	shadowbind_cb_data *cb_data = op->o_callback->sc_private;
+	slap_overinst *on = (slap_overinst *) cb_data->on;
+	shadowbind_cfg *cfg = (shadowbind_cfg *) on->on_bi.bi_private;
+
+	/* rootdn/updatedn bypasses policy */
+	if ( be_isroot_dn( op->o_bd, &op->o_req_ndn ) || be_isupdate_dn( op->o_bd, &op->o_req_ndn ) ) {
+		Debug( LDAP_DEBUG_TRACE, "shadowbind_bind_response: ignore root/update dn %s\n", op->o_req_ndn.bv_val, 0, 0 );
+		return SLAP_CB_CONTINUE;
+	}
+
+	/* get entry */
+	if ( LDAP_SUCCESS != overlay_entry_get_ov(op, &op->o_req_ndn, NULL, NULL, 0, &e, on) ) {
+		return SLAP_CB_CONTINUE;
+	}
+
+	/* ignore non shadowAccount objects */
+	if ( !is_entry_objectclass(e, oc_shadowAccount, 0 ) ) {
+		Debug( LDAP_DEBUG_TRACE, "shadowbind_bind_response: ignore non shadowAccount %s\n", op->o_req_ndn.bv_val, 0, 0 );
+		goto done;
+	}
+
+	/* ignore objects that match the ignore filter */
+	if ( cfg->ignore_filter && test_filter( NULL, e, cfg->ignore_filter ) == LDAP_COMPARE_TRUE ) {
+		Debug( LDAP_DEBUG_TRACE, "shadowbind_bind_response: object %s matches ignore filter", op->o_req_ndn.bv_val, 0, 0 );
+		goto done;
+	}
+
+	/* shadowExpire */
+	a = attr_find(e->e_attrs, attr_shadowExpire);
+	if ( a != NULL && a->a_nvals[0].bv_val != NULL ) {
+		long expire = strtol( a->a_nvals[0].bv_val, NULL, 0 );
+		Debug( LDAP_DEBUG_TRACE, "shadowbind_bind_response: shadowExpire %ld\n", expire, 0, 0 );
+		if ( expire ) {
+			now = time(NULL) / 3600 / 24;
+			if ( now >= expire ) {
+				send_ldap_error(op, rs, LDAP_INVALID_CREDENTIALS, "account expired");
+				ret = rs->sr_err;
+				goto done;
+			}
+		}
+	}
+
+	/* shadowMax + shadowLastChange > now ? */
+	a = attr_find( e->e_attrs, attr_shadowMax );
+	if ( a != NULL && a->a_nvals[0].bv_val != NULL ) {
+		long max = strtol( a->a_nvals[0].bv_val, NULL, 0 );
+		Debug( LDAP_DEBUG_TRACE, "shadowbind_bind_response: shadowMax %ld\n", max, 0, 0 );
+		if ( max ) {
+			a = attr_find( e->e_attrs, attr_shadowLastChange);
+			if ( a != NULL && a->a_nvals[0].bv_val != NULL ) {
+				long lastChange = strtol( a->a_nvals[0].bv_val, NULL, 0 );
+				Debug( LDAP_DEBUG_TRACE, "shadowbind_bind_response: shadowLastChange %ld\n", lastChange, 0, 0 );
+				if ( lastChange ) {
+					if ( now == 0 )
+						now = time(NULL) / 3600 / 24;
+					if ( now - lastChange > max ) {
+						send_ldap_error( op, rs, LDAP_INVALID_CREDENTIALS, "password expired" );
+						ret = rs->sr_err;
+						goto done;
+					}
+				}
+			}
+		}
+	}
+
+done:
+	overlay_entry_release_ov(op, e, 0, on);
+	return ret;
+}
+
+static int
+shadowbind_op_bind ( Operation *op, SlapReply *rs )
+{
+	Debug( LDAP_DEBUG_TRACE, "shadowbind_op_bind\n", 0, 0, 0 );
+
+	slap_callback *cb;
+	shadowbind_cb_data *cb_data;
+	slap_overinst *on = (slap_overinst *) op->o_bd->bd_info;
+
+	/* setup a callback to intercept result of this bind operation
+	 * and pass along the callback data struct */
+	cb = op->o_tmpcalloc( sizeof(slap_callback) + sizeof(shadowbind_cb_data) , 1, op->o_tmpmemctx );
+	cb->sc_response = shadowbind_bind_response;
+	cb->sc_private = cb+1;
+	cb->sc_next = op->o_callback->sc_next;
+	cb_data = cb->sc_private;
+	cb_data->on = on;
+	op->o_callback->sc_next = cb;
+
+	return SLAP_CB_CONTINUE;
+}
+
+static int
+shadowbind_db_config( BackendDB *be, const char *fname, int lineno, int argc, char **argv )
+{
+	Debug( LDAP_DEBUG_CONFIG|LDAP_DEBUG_TRACE, "shadowbind_db_config\n", 0, 0, 0 );
+
+	slap_overinst *on = (slap_overinst *) be->bd_info;
+	shadowbind_cfg *cfg = on->on_bi.bi_private;
+
+	/* ignore filter */
+	if ( strcasecmp( argv[0], "shadowbind-ignore-filter" ) == 0 ) {
+		if ( argc != 2 ) {
+			Debug( LDAP_DEBUG_ANY,
+				"%s: line %d: \"shadowbind-ignore-filter\" needs 1 argument\n",
+				fname, lineno, 0 );
+			return(1);
+		}
+		cfg->ignore_filter = str2filter(argv[1]);
+		if ( !cfg->ignore_filter ) {
+			Debug( LDAP_DEBUG_ANY,
+				"%s: line %d: \"shadowbind-ignore-filter\" bad filter: %s\n",
+				fname, lineno, argv[1] );
+			return(1);
+		}
+	}
+
+	return 0;
+}
+
+
+static slap_overinst shadowbind;
+
+int
+shadowbind_initialize(void)
+{
+	int rc;
+
+	shadowbind.on_bi.bi_type = "shadowbind";
+	shadowbind.on_bi.bi_db_init = shadowbind_db_init;
+	shadowbind.on_bi.bi_db_open = shadowbind_db_open;
+	shadowbind.on_bi.bi_db_destroy = shadowbind_db_destroy;
+	shadowbind.on_bi.bi_op_bind = shadowbind_op_bind;
+	shadowbind.on_bi.bi_db_config = shadowbind_db_config;
+
+	/* dynamic config, postponed
+
+	shadowbind.on_bi.bi_cf_ocs = shadowbind_cfg_ocs;
+	rc = config_register_schema( shadowbind_cfg_attrs, shadowbind_cfg_ocs );
+	if ( rc ) return rc;
+
+	*/
+
+	return overlay_register( &shadowbind );
+}
+
+#if SLAPD_OVER_SHADOWBIND == SLAPD_MOD_DYNAMIC
+
+int
+init_module( int argc, char *argv[] )
+{
+	Debug( LDAP_DEBUG_TRACE, "Loading shadowbind Overlay.", 0, 0, 0 );
+
+	return shadowbind_initialize();
+}
+
+#endif /* SLAPD_OVER_SHADOWBIND == SLAPD_MOD_DYNAMIC */
+
+#endif /* SLAPD_OVER_SHADOWBIND */
+
