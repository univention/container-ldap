Added this overlay module based on smbk5pwd which allows to set
{K5KEY} to userPassword flag. As opposed to smbk5pwd this module
doesn't change the passwords.

UCS Bug #15062
https://forge.univention.org/bugzilla/show_bug.cgi?id=15062

Integrated Changes:
* Bug #31352: Abort if the password is empty.Check return codes of krb5_string_to_key_salt and other operations.
* Bug #50492: Use the correct salt for hash comparison, not the default salt.

diff -Nuar -x '*.orig' openldap-2.4.31.orig/contrib/slapd-modules/k5pwd/k5pwd.c openldap-2.4.31/contrib/slapd-modules/k5pwd/k5pwd.c
--- openldap-2.4.31.orig/contrib/slapd-modules/k5pwd/k5pwd.c	1970-01-01 01:00:00.000000000 +0100
+++ openldap-2.4.31/contrib/slapd-modules/k5pwd/k5pwd.c	2012-07-19 14:41:49.316917409 +0200
@@ -0,0 +1,676 @@
+/* k5pwd.c - This module was copied from smbk5pwd */
+/* This work is part of OpenLDAP Software <http://www.openldap.org/>.
+ *
+ * Copyright 2004-2011 The OpenLDAP Foundation.
+ * Portions Copyright 2004-2005 by Howard Chu, Symas Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted only as authorized by the OpenLDAP
+ * Public License.
+ *
+ * A copy of this license is available in the file LICENSE in the
+ * top-level directory of the distribution or, alternatively, at
+ * <http://www.OpenLDAP.org/license.html>.
+ */
+/* ACKNOWLEDGEMENTS:
+ * Support for table-driven configuration added by Pierangelo Masarati.
+ * Support for sambaPwdMustChange and sambaPwdCanChange added by Marco D'Ettorre.
+ */
+
+#include <portable.h>
+
+#ifndef SLAPD_OVER_K5PWD
+#define SLAPD_OVER_K5PWD SLAPD_MOD_DYNAMIC
+#endif
+
+#ifdef SLAPD_OVER_K5PWD
+
+#include <slap.h>
+#include <ac/errno.h>
+#include <ac/string.h>
+
+#include "config.h"
+
+#ifdef SUPPORT_K5KEY_SCHEME
+#include <lber.h>
+#include <lber_pvt.h>
+#include <lutil.h>
+
+/* make ASN1_MALLOC_ENCODE use our allocator */
+#define malloc	ch_malloc
+
+#include <krb5.h>
+#include <kadm5/admin.h>
+#include <hdb.h>
+#include <heimdal/wind_err.h>
+
+#ifndef HDB_INTERFACE_VERSION
+#define	HDB_MASTER_KEY_SET	master_key_set
+#else
+#define	HDB_MASTER_KEY_SET	hdb_master_key_set
+#endif
+
+static krb5_context context;
+static void *kadm_context;
+static kadm5_config_params conf;
+static HDB *db;
+
+static AttributeDescription *ad_krb5Key;
+static AttributeDescription *ad_krb5KeyVersionNumber;
+static AttributeDescription *ad_krb5PrincipalName;
+static AttributeDescription *ad_krb5ValidEnd;
+static ObjectClass *oc_krb5KDCEntry;
+#endif
+
+/* Per-instance configuration information */
+typedef struct k5pwd_t {
+	unsigned	mode;
+#define	K5PWD_F_KRB5		(0x1U)
+#define	K5PWD_F_SAMBA	(0x2U)
+#define	K5PWD_F_K5KEY	(0x4U)
+
+#define K5PWD_DO_KRB5(pi)	((pi)->mode & K5PWD_F_KRB5)
+#define K5PWD_DO_SAMBA(pi)	((pi)->mode & K5PWD_F_SAMBA)
+#define K5PWD_SUPPORT_K5KEY_SCHEME(pi)	((pi)->mode & K5PWD_F_K5KEY)
+
+} k5pwd_t;
+
+static const unsigned K5PWD_F_ALL	=
+	0
+#ifdef SUPPORT_K5KEY_SCHEME
+	| K5PWD_F_K5KEY
+#endif
+;
+
+static int k5pwd_modules_init( k5pwd_t *pi );
+
+#ifdef SUPPORT_K5KEY_SCHEME
+
+static int k5pwd_op_cleanup(
+	Operation *op,
+	SlapReply *rs )
+{
+	slap_callback *cb;
+
+	/* clear out the current key */
+	ldap_pvt_thread_pool_setkey( op->o_threadctx, k5pwd_op_cleanup,
+		NULL, 0, NULL, NULL );
+
+	/* free the callback */
+	cb = op->o_callback;
+	op->o_callback = cb->sc_next;
+	op->o_tmpfree( cb, op->o_tmpmemctx );
+	return 0;
+}
+
+static int k5pwd_op_bind(
+	Operation *op,
+	SlapReply *rs )
+{
+	/* If this is a simple Bind, stash the Op pointer so our chk
+	 * function can find it. Set a cleanup callback to clear it
+	 * out when the Bind completes.
+	 */
+	if ( op->oq_bind.rb_method == LDAP_AUTH_SIMPLE ) {
+		slap_callback *cb;
+		ldap_pvt_thread_pool_setkey( op->o_threadctx,
+			k5pwd_op_cleanup, op, 0, NULL, NULL );
+		cb = op->o_tmpcalloc( 1, sizeof(slap_callback), op->o_tmpmemctx );
+		cb->sc_cleanup = k5pwd_op_cleanup;
+		cb->sc_next = op->o_callback;
+		op->o_callback = cb;
+	}
+	return SLAP_CB_CONTINUE;
+}
+
+static LUTIL_PASSWD_CHK_FUNC k5key_chk;
+static LUTIL_PASSWD_HASH_FUNC k5key_hash;
+static const struct berval k5key_scheme = BER_BVC("{K5KEY}");
+
+/* This password scheme stores no data in the userPassword attribute
+ * other than the scheme name. It assumes the invoking entry is a
+ * krb5KDCentry and compares the passed-in credentials against the
+ * krb5Key attribute. The krb5Key may be multi-valued, but they are
+ * simply multiple keytypes generated from the same input string, so
+ * only the first value needs to be compared here.
+ *
+ * Since the lutil_passwd API doesn't pass the Entry object in, we
+ * have to fetch it ourselves in order to get access to the other
+ * attributes. We accomplish this with the help of the overlay's Bind
+ * function, which stores the current Operation pointer in thread-specific
+ * storage so we can retrieve it here. The Operation provides all
+ * the necessary context for us to get Entry from the database.
+ */
+static int k5key_chk(
+	const struct berval *sc,
+	const struct berval *passwd,
+	const struct berval *cred,
+	const char **text )
+{
+	void *ctx, *op_tmp;
+	Operation *op;
+	int rc;
+	Entry *e;
+	Attribute *a, *a_krb5PrincipalName;
+	krb5_error_code ret;
+	krb5_keyblock key;
+	krb5_salt salt = {0};
+	hdb_entry ent;
+	int decode_ret;
+
+	/* Find our thread context, find our Operation */
+	ctx = ldap_pvt_thread_pool_context();
+
+	if ( ldap_pvt_thread_pool_getkey( ctx, k5pwd_op_cleanup, &op_tmp, NULL )
+		 || !op_tmp )
+		return LUTIL_PASSWD_ERR;
+	op = op_tmp;
+
+	rc = be_entry_get_rw( op, &op->o_req_ndn, NULL, NULL, 0, &e );
+	if ( rc != LDAP_SUCCESS ) return LUTIL_PASSWD_ERR;
+
+	/* In this case the password is empty. This happened in one customer
+	   environment:
+	   https://forge.univention.org/bugzilla/show_bug.cgi?id=28166
+	*/
+	if ( cred->bv_len == 0 )
+		return LUTIL_PASSWD_ERR;
+
+	rc = LUTIL_PASSWD_ERR;
+	do {
+		size_t l;
+		Key ekey = {0};
+
+		a_krb5PrincipalName = attr_find( e->e_attrs, ad_krb5PrincipalName );
+		if (!a_krb5PrincipalName ) break;
+
+		memset( &ent, 0, sizeof(ent) );
+		ret = krb5_parse_name(context, a_krb5PrincipalName->a_vals[0].bv_val, &ent.principal);
+		if ( ret ) break;
+
+		a = attr_find( e->e_attrs, ad_krb5ValidEnd );
+		if (a) {
+			struct lutil_tm tm;
+			struct lutil_timet tt;
+			if ( lutil_parsetime( a->a_vals[0].bv_val, &tm ) == 0 &&
+				lutil_tm2time( &tm, &tt ) == 0 && tt.tt_sec < op->o_time ) {
+				/* Account is expired */
+				rc = LUTIL_PASSWD_ERR;
+				break;
+			}
+		}
+
+		krb5_free_principal( context, ent.principal );
+
+		a = attr_find( e->e_attrs, ad_krb5Key );
+		if ( !a ) break;
+
+		decode_ret = decode_Key((unsigned char *) a->a_vals[0].bv_val,
+			(size_t) a->a_vals[0].bv_len, &ekey, &l);
+
+		if (decode_ret) {
+			const char *error_string;
+			error_string = krb5_get_error_message( context, ret );
+			Debug( LDAP_DEBUG_ANY, "%s: k5pwd: "
+				"k5key_chk: decode_Key failed for: %s.\n",
+				op->o_log_prefix, a_krb5PrincipalName->a_vals[0].bv_val, 0 );
+			if (error_string) {
+				Debug( LDAP_DEBUG_ANY, "%s: k5pwd: "
+					"k5key_chk: error_string: %s.\n",
+					op->o_log_prefix, error_string, 0 );
+				krb5_free_error_message(context, error_string);
+			} else {
+				Debug( LDAP_DEBUG_ANY, "%s: k5pwd: "
+					"k5key_chk: ret=%d.\n",
+					op->o_log_prefix, ret, 0 );
+			}
+
+			krb5_free_salt( context, salt );
+			rc = LUTIL_PASSWD_ERR;
+			break;
+		}
+		if (ekey.salt) {
+			salt.saltvalue.data = ekey.salt->salt.data;
+			salt.saltvalue.length = ekey.salt->salt.length;
+		}
+		salt.salttype = KRB5_PW_SALT;
+
+		if ( db->HDB_MASTER_KEY_SET )
+			hdb_unseal_keys( context, db, &ent );
+
+		ret = krb5_string_to_key_salt( context, ekey.key.keytype, cred->bv_val,
+			salt, &key );
+
+		krb5_free_salt( context, salt );
+
+		if (ret) {
+			Debug( LDAP_DEBUG_ANY, "%s: k5pwd: "
+				"k5key_chk: krb5_string_to_key_salt failed for: %s.\n",
+				op->o_log_prefix, a_krb5PrincipalName->a_vals[0].bv_val, 0 );
+			if(ret == WIND_ERR_INVALID_UTF8) {	// special message for error_string "<unknown error: -969269754>":
+				Debug( LDAP_DEBUG_ANY, "%s: k5pwd: "
+					"k5key_chk: error_string: The password is not encoded as UTF-8 (ret=%d).\n",
+					op->o_log_prefix, ret, 0 );
+			} else {
+				const char *error_string;
+				error_string = krb5_get_error_message( context, ret );
+				if (error_string) {
+					Debug( LDAP_DEBUG_ANY, "%s: k5pwd: "
+						"k5key_chk: error_string: %s.\n",
+						op->o_log_prefix, error_string, 0 );
+					krb5_free_error_message(context, error_string);
+				} else {
+					Debug( LDAP_DEBUG_ANY, "%s: k5pwd: "
+						"k5key_chk: ret=%d.\n",
+						op->o_log_prefix, ret, 0 );
+				}
+			}
+
+			krb5_free_keyblock_contents( context, &ekey.key );
+			rc = LUTIL_PASSWD_ERR;
+			break;
+		}
+
+		if ( memcmp( ekey.key.keyvalue.data, key.keyvalue.data,
+			key.keyvalue.length ) == 0 ) rc = LUTIL_PASSWD_OK;
+
+		krb5_free_keyblock_contents( context, &key );
+		krb5_free_keyblock_contents( context, &ekey.key );
+
+	} while(0);
+	be_entry_release_r( op, e );
+	return rc;
+}
+
+static int k5key_hash(
+	const struct berval *scheme,
+	const struct berval *passwd,
+	struct berval *hash,
+	const char **text )
+{
+	ber_dupbv( hash, (struct berval *)&k5key_scheme );
+	return LUTIL_PASSWD_OK;
+}
+#endif /* SUPPORT_K5KEY_SCHEME */
+
+static int k5pwd_exop_passwd(
+	Operation *op,
+	SlapReply *rs )
+{
+	int rc;
+	req_pwdexop_s *qpw = &op->oq_pwdexop;
+	Entry *e;
+	Modifications *ml;
+	slap_overinst *on = (slap_overinst *)op->o_bd->bd_info;
+	k5pwd_t *pi = on->on_bi.bi_private;
+	char term;
+
+	/* Not the operation we expected, pass it on... */
+	if ( ber_bvcmp( &slap_EXOP_MODIFY_PASSWD, &op->ore_reqoid ) ) {
+		return SLAP_CB_CONTINUE;
+	}
+
+	op->o_bd->bd_info = (BackendInfo *)on->on_info;
+	rc = be_entry_get_rw( op, &op->o_req_ndn, NULL, NULL, 0, &e );
+	if ( rc != LDAP_SUCCESS ) return rc;
+
+	term = qpw->rs_new.bv_val[qpw->rs_new.bv_len];
+	qpw->rs_new.bv_val[qpw->rs_new.bv_len] = '\0';
+
+	be_entry_release_r( op, e );
+	qpw->rs_new.bv_val[qpw->rs_new.bv_len] = term;
+
+	return SLAP_CB_CONTINUE;
+}
+
+static slap_overinst k5pwd;
+
+/* back-config stuff */
+enum {
+	PC_SMB_MUST_CHANGE = 1,
+	PC_SMB_CAN_CHANGE,
+	PC_SMB_ENABLE
+};
+
+static ConfigDriver k5pwd_cf_func;
+
+/*
+ * NOTE: uses OID arcs OLcfgCtAt:1 and OLcfgCtOc:1
+ */
+
+static ConfigTable k5pwd_cfats[] = {
+	{ "k5pwd-enable", "arg",
+		2, 0, 0, ARG_MAGIC|PC_SMB_ENABLE, k5pwd_cf_func,
+		"( OLcfgCtAt:1.1 NAME 'olcSmbK5PwdEnable' "
+		"DESC 'Modules to be enabled' "
+		"SYNTAX OMsDirectoryString )", NULL, NULL },
+	{ "k5pwd-must-change", "time",
+		2, 2, 0, ARG_MAGIC|ARG_INT|PC_SMB_MUST_CHANGE, k5pwd_cf_func,
+		"( OLcfgCtAt:1.2 NAME 'olcSmbK5PwdMustChange' "
+		"DESC 'Credentials validity interval' "
+		"SYNTAX OMsInteger SINGLE-VALUE )", NULL, NULL },
+	{ "k5pwd-can-change", "time",
+		2, 2, 0, ARG_MAGIC|ARG_INT|PC_SMB_CAN_CHANGE, k5pwd_cf_func,
+		"( OLcfgCtAt:1.3 NAME 'olcSmbK5PwdCanChange' "
+		"DESC 'Credentials minimum validity interval' "
+		"SYNTAX OMsInteger SINGLE-VALUE )", NULL, NULL },
+
+	{ NULL, NULL, 0, 0, 0, ARG_IGNORED }
+};
+
+static ConfigOCs k5pwd_cfocs[] = {
+	{ "( OLcfgCtOc:1.1 "
+		"NAME 'olcSmbK5PwdConfig' "
+		"DESC 'k5pwd overlay configuration' "
+		"SUP olcOverlayConfig "
+		"MAY ( "
+			"olcSmbK5PwdEnable "
+			"$ olcSmbK5PwdMustChange "
+			"$ olcSmbK5PwdCanChange "
+		") )", Cft_Overlay, k5pwd_cfats },
+
+	{ NULL, 0, NULL }
+};
+
+/*
+ * add here other functionalities; handle their initialization
+ * as appropriate in k5pwd_modules_init().
+ */
+static slap_verbmasks k5pwd_modules[] = {
+	{ BER_BVC( "krb5" ),		K5PWD_F_KRB5	},
+	{ BER_BVC( "samba" ),		K5PWD_F_SAMBA },
+	{ BER_BVNULL,			-1 }
+};
+
+static int
+k5pwd_cf_func( ConfigArgs *c )
+{
+	slap_overinst	*on = (slap_overinst *)c->bi;
+
+	int		rc = 0;
+	k5pwd_t	*pi = on->on_bi.bi_private;
+
+	if ( c->op == SLAP_CONFIG_EMIT ) {
+		switch( c->type ) {
+		case PC_SMB_MUST_CHANGE:
+			c->value_int = 0;
+			break;
+
+		case PC_SMB_CAN_CHANGE:
+			c->value_int = 0;
+			break;
+
+		case PC_SMB_ENABLE:
+			c->rvalue_vals = NULL;
+			if ( pi->mode ) {
+				mask_to_verbs( k5pwd_modules, pi->mode, &c->rvalue_vals );
+				if ( c->rvalue_vals == NULL ) {
+					rc = 1;
+				}
+			}
+			break;
+
+		default:
+			assert( 0 );
+			rc = 1;
+		}
+		return rc;
+
+	} else if ( c->op == LDAP_MOD_DELETE ) {
+		switch( c->type ) {
+		case PC_SMB_MUST_CHANGE:
+			break;
+
+                case PC_SMB_CAN_CHANGE:
+                        break;
+
+		case PC_SMB_ENABLE:
+			if ( !c->line ) {
+				pi->mode = 0;
+
+			} else {
+				slap_mask_t	m;
+
+				m = verb_to_mask( c->line, k5pwd_modules );
+				pi->mode &= ~m;
+			}
+			break;
+
+		default:
+			assert( 0 );
+			rc = 1;
+		}
+		return rc;
+	}
+
+	switch( c->type ) {
+	case PC_SMB_MUST_CHANGE:
+		Debug( LDAP_DEBUG_TRACE, "%s: k5pwd: "
+			"<%s> only meaningful "
+			"when compiled with -DDO_SAMBA.\n",
+			c->log, c->argv[ 0 ], 0 );
+		return 1;
+		break;
+
+        case PC_SMB_CAN_CHANGE:
+                Debug( LDAP_DEBUG_TRACE, "%s: k5pwd: "
+                        "<%s> only meaningful "
+                        "when compiled with -DDO_SAMBA.\n",
+                        c->log, c->argv[ 0 ], 0 );
+                return 1;
+                break;
+
+	case PC_SMB_ENABLE: {
+		slap_mask_t	mode = pi->mode, m;
+
+		rc = verbs_to_mask( c->argc, c->argv, k5pwd_modules, &m );
+		if ( rc > 0 ) {
+			Debug( LDAP_DEBUG_TRACE, "%s: k5pwd: "
+				"<%s> unknown module \"%s\".\n",
+				c->log, c->argv[ 0 ], c->argv[ rc ] );
+			return 1;
+		}
+
+		/* we can hijack the k5pwd_t structure because
+		 * from within the configuration, this is the only
+		 * active thread. */
+		pi->mode |= m;
+
+
+		{
+			BackendDB	db = *c->be;
+
+			/* Re-initialize the module, because
+			 * the configuration might have changed */
+			db.bd_info = (BackendInfo *)on;
+			rc = k5pwd_modules_init( pi );
+			if ( rc ) {
+				pi->mode = mode;
+				return 1;
+			}
+		}
+
+		} break;
+
+	default:
+		assert( 0 );
+		return 1;
+	}
+	return rc;
+}
+
+static int
+k5pwd_modules_init( k5pwd_t *pi )
+{
+	static struct {
+		const char		*name;
+		AttributeDescription	**adp;
+	}
+#ifdef SUPPORT_K5KEY_SCHEME
+	krb5_ad[] = {
+		{ "krb5Key",			&ad_krb5Key },
+		{ "krb5KeyVersionNumber",	&ad_krb5KeyVersionNumber },
+		{ "krb5PrincipalName",		&ad_krb5PrincipalName },
+		{ "krb5ValidEnd",		&ad_krb5ValidEnd },
+		{ NULL }
+	},
+#endif /* SUPPORT_K5KEY_SCHEME */
+	dummy_ad;
+
+	/* this is to silence the unused var warning */
+	dummy_ad.name = NULL;
+
+#ifdef SUPPORT_K5KEY_SCHEME
+	if ( (K5PWD_SUPPORT_K5KEY_SCHEME( pi ) || K5PWD_DO_KRB5( pi )) && oc_krb5KDCEntry == NULL ) {
+		krb5_error_code	ret;
+		extern HDB 	*_kadm5_s_get_db(void *);
+
+		int		i, rc;
+
+		/* Make sure all of our necessary schema items are loaded */
+		oc_krb5KDCEntry = oc_find( "krb5KDCEntry" );
+		if ( !oc_krb5KDCEntry ) {
+			Debug( LDAP_DEBUG_ANY, "k5pwd: "
+				"unable to find \"krb5KDCEntry\" objectClass.\n",
+				0, 0, 0 );
+			return -1;
+		}
+
+		for ( i = 0; krb5_ad[ i ].name != NULL; i++ ) {
+			const char	*text;
+
+			*(krb5_ad[ i ].adp) = NULL;
+
+			rc = slap_str2ad( krb5_ad[ i ].name, krb5_ad[ i ].adp, &text );
+			if ( rc != LDAP_SUCCESS ) {
+				Debug( LDAP_DEBUG_ANY, "k5pwd: "
+					"unable to find \"%s\" attributeType: %s (%d).\n",
+					krb5_ad[ i ].name, text, rc );
+				oc_krb5KDCEntry = NULL;
+				return rc;
+			}
+		}
+
+		/* Initialize Kerberos context */
+		ret = krb5_init_context(&context);
+		if (ret) {
+			Debug( LDAP_DEBUG_ANY, "k5pwd: "
+				"unable to initialize krb5 context (%d).\n",
+				ret, 0, 0 );
+			oc_krb5KDCEntry = NULL;
+			return -1;
+		}
+
+		ret = kadm5_s_init_with_password_ctx( context,
+			KADM5_ADMIN_SERVICE,
+			NULL,
+			KADM5_ADMIN_SERVICE,
+			&conf, 0, 0, &kadm_context );
+		if (ret) {
+			char *err_str, *err_msg = "<unknown error>";
+			err_str = krb5_get_error_string( context );
+			if (!err_str)
+				err_msg = (char *)krb5_get_err_text( context, ret );
+			Debug( LDAP_DEBUG_ANY, "k5pwd: "
+				"unable to initialize krb5 admin context: %s (%d).\n",
+				err_str ? err_str : err_msg, ret, 0 );
+			if (err_str)
+				krb5_free_error_string( context, err_str );
+			krb5_free_context( context );
+			oc_krb5KDCEntry = NULL;
+			return -1;
+		}
+
+		db = _kadm5_s_get_db( kadm_context );
+	}
+#endif /* SUPPORT_K5KEY_SCHEME */
+
+
+	return 0;
+}
+
+static int
+k5pwd_db_init(BackendDB *be, ConfigReply *cr)
+{
+	slap_overinst	*on = (slap_overinst *)be->bd_info;
+	k5pwd_t	*pi;
+
+	pi = ch_calloc( 1, sizeof( k5pwd_t ) );
+	if ( pi == NULL ) {
+		return 1;
+	}
+	on->on_bi.bi_private = (void *)pi;
+
+	return 0;
+}
+
+static int
+k5pwd_db_open(BackendDB *be, ConfigReply *cr)
+{
+	slap_overinst	*on = (slap_overinst *)be->bd_info;
+	k5pwd_t	*pi = (k5pwd_t *)on->on_bi.bi_private;
+
+	int	rc;
+
+	if ( pi->mode == 0 ) {
+		pi->mode = K5PWD_F_ALL;
+	}
+
+	rc = k5pwd_modules_init( pi );
+	if ( rc ) {
+		return rc;
+	}
+
+	return 0;
+}
+
+static int
+k5pwd_db_destroy(BackendDB *be, ConfigReply *cr)
+{
+	slap_overinst	*on = (slap_overinst *)be->bd_info;
+	k5pwd_t	*pi = (k5pwd_t *)on->on_bi.bi_private;
+
+	if ( pi ) {
+		ch_free( pi );
+	}
+
+	return 0;
+}
+
+int
+k5pwd_initialize(void)
+{
+	int		rc;
+
+	k5pwd.on_bi.bi_type = "k5pwd";
+
+	k5pwd.on_bi.bi_db_init = k5pwd_db_init;
+	k5pwd.on_bi.bi_db_open = k5pwd_db_open;
+	k5pwd.on_bi.bi_db_destroy = k5pwd_db_destroy;
+
+	k5pwd.on_bi.bi_extended = k5pwd_exop_passwd;
+    
+#ifdef SUPPORT_K5KEY_SCHEME
+	k5pwd.on_bi.bi_op_bind = k5pwd_op_bind;
+
+	lutil_passwd_add( (struct berval *)&k5key_scheme, k5key_chk, k5key_hash );
+#endif
+
+	k5pwd.on_bi.bi_cf_ocs = k5pwd_cfocs;
+
+	rc = config_register_schema( k5pwd_cfats, k5pwd_cfocs );
+	if ( rc ) {
+		return rc;
+	}
+
+	return overlay_register( &k5pwd );
+}
+
+#if SLAPD_OVER_K5PWD == SLAPD_MOD_DYNAMIC
+int init_module(int argc, char *argv[]) {
+	return k5pwd_initialize();
+}
+#endif
+
+#endif /* defined(SLAPD_OVER_K5PWD) */
diff -Nuar -x '*.orig' openldap-2.4.31.orig/contrib/slapd-modules/k5pwd/Makefile openldap-2.4.31/contrib/slapd-modules/k5pwd/Makefile
--- openldap-2.4.31.orig/contrib/slapd-modules/k5pwd/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ openldap-2.4.31/contrib/slapd-modules/k5pwd/Makefile	2012-07-19 14:41:49.320916896 +0200
@@ -0,0 +1,70 @@
+# $OpenLDAP pkg/ldap/contrib/slapd-modules/k5pwd/Makefile,v 1.1.6.6 2011/01/04 23:49:36 kurt Exp $
+# This work is part of OpenLDAP Software <http://www.openldap.org/>.
+#
+# Copyright 1998-2018 The OpenLDAP Foundation.
+# Copyright 2004 Howard Chu, Symas Corp. All Rights Reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted only as authorized by the OpenLDAP
+# Public License.
+#
+# A copy of this license is available in the file LICENSE in the
+# top-level directory of the distribution or, alternatively, at
+# <http://www.OpenLDAP.org/license.html>.
+
+LDAP_SRC = ../../..
+LDAP_BUILD = $(LDAP_SRC)
+LDAP_INC = -I$(LDAP_BUILD)/include -I$(LDAP_SRC)/include -I$(LDAP_SRC)/servers/slapd
+LDAP_LIB = $(LDAP_BUILD)/libraries/libldap_r/libldap_r.la \
+	$(LDAP_BUILD)/libraries/liblber/liblber.la
+
+SSL_INC = 
+SSL_LIB = -lnettle
+
+HEIMDAL_INC = $(shell krb5-config.heimdal --cflags kadm-server)
+HEIMDAL_LIB = $(shell krb5-config.heimdal --libs kadm-server)
+
+LIBTOOL = $(LDAP_BUILD)/libtool
+INSTALL = /usr/bin/install
+CC = gcc
+OPT = -g -O2 -Wall
+DEFS=-DSUPPORT_K5KEY_SCHEME
+INCS = $(LDAP_INC) $(HEIMDAL_INC) $(SSL_INC)
+# put /usr/lib/heimdal before /usr/lib in case libkrb5-dev is installed, #745356
+LIBS = $(HEIMDAL_LIB) $(LDAP_LIB) $(SSL_LIB)
+
+PROGRAMS = k5pwd.la
+LTVER = 0:0:0
+
+prefix=/usr/local
+exec_prefix=$(prefix)
+ldap_subdir=/openldap
+
+libdir=$(exec_prefix)/lib
+libexecdir=$(exec_prefix)/libexec
+moduledir = $(libexecdir)$(ldap_subdir)
+
+.SUFFIXES: .c .o .lo
+
+.c.lo:
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(CPPFLAGS) $(DEFS) $(INCS) -c $<
+
+all: $(PROGRAMS)
+
+k5pwd.la:	k5pwd.lo
+	$(LIBTOOL) --mode=link $(CC) $(LDFLAGS) -version-info $(LTVER) \
+	-rpath $(moduledir) -module -o $@ $? $(LIBS)
+
+clean:
+	rm -rf *.o *.lo *.la .libs
+
+install: install-lib FORCE
+
+install-lib: $(PROGRAMS)
+	mkdir -p $(DESTDIR)$(moduledir)
+	for p in $(PROGRAMS) ; do \
+		$(LIBTOOL) --mode=install cp $$p $(DESTDIR)$(moduledir) ; \
+	done
+
+FORCE:
+
diff -Nuar -x '*.orig' openldap-2.4.31.orig/contrib/slapd-modules/k5pwd/README openldap-2.4.31/contrib/slapd-modules/k5pwd/README
--- openldap-2.4.31.orig/contrib/slapd-modules/k5pwd/README	1970-01-01 01:00:00.000000000 +0100
+++ openldap-2.4.31/contrib/slapd-modules/k5pwd/README	2012-07-19 14:41:49.320916896 +0200
@@ -0,0 +1,2 @@
+This module was copied from smbk5pwd.
+
