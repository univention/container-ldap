This patch adds a new overlay module pwd_scheme_kinit. It allows to set
the userPassword attribute to {KINIT}. The overlay module checks the
password against the Kerberos KDC.  It can be used to authenticate
against an Active Directory domain.

UCS Bug: https://forge.univention.org/bugzilla/show_bug.cgi?id=35092

--- openldap-2.4.35.orig/contrib/slapd-modules/pwd_scheme_kinit/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ openldap-2.4.35/contrib/slapd-modules/pwd_scheme_kinit/Makefile	2014-02-08 11:46:31.540000000 +0100
@@ -0,0 +1,97 @@
+#
+# Copyright 2014 Univention GmbH
+#
+# http://www.univention.de/
+#
+# All rights reserved.
+#
+# The source code of this program is made available
+# under the terms of the GNU Affero General Public License version 3
+# (GNU AGPL V3) as published by the Free Software Foundation.
+#
+# Binary versions of this program provided by Univention to you as
+# well as other copyrighted, protected or trademarked materials like
+# Logos, graphics, fonts, specific documentations and configurations,
+# cryptographic keys etc. are subject to a license agreement between
+# you and Univention and not subject to the GNU AGPL V3.
+#
+# In the case you use this program under the terms of the GNU AGPL V3,
+# the program is provided in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU Affero General Public License for more details.
+#
+# You should have received a copy of the GNU Affero General Public
+# License with the Debian GNU/Linux or Univention distribution in file
+# /usr/share/common-licenses/AGPL-3; if not, see
+# <http://www.gnu.org/licenses/>.
+
+# This work has been derived from parts of OpenLDAP Software <http://www.openldap.org/>.
+#
+# Copyright 1998-2011 The OpenLDAP Foundation.
+# Copyright 2004 Howard Chu, Symas Corp. All Rights Reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted only as authorized by the OpenLDAP
+# Public License.
+#
+# A copy of this license is available in the file LICENSE in the
+# top-level directory of the distribution or, alternatively, at
+# <http://www.OpenLDAP.org/license.html>.
+
+LDAP_SRC = ../../..
+LDAP_BUILD = $(LDAP_SRC)
+LDAP_INC = -I$(LDAP_BUILD)/include -I$(LDAP_SRC)/include -I$(LDAP_SRC)/servers/slapd
+LDAP_LIB = $(LDAP_BUILD)/libraries/libldap_r/libldap_r.la \
+	$(LDAP_BUILD)/libraries/liblber/liblber.la
+
+SSL_INC = 
+SSL_LIB = -lnettle
+
+HEIMDAL_INC = $(shell krb5-config.heimdal --cflags kadm-server)
+HEIMDAL_LIB = $(shell krb5-config.heimdal --libs kadm-server)
+
+LIBTOOL = $(LDAP_BUILD)/libtool
+INSTALL = /usr/bin/install
+CC = gcc
+OPT = -g -O2 -Wall
+DEFS=-DACTIVATE_PWD_SCHEME_KINIT_BY_DEFAULT
+INCS = $(LDAP_INC) $(HEIMDAL_INC) $(SSL_INC)
+# put /usr/lib/heimdal before /usr/lib in case libkrb5-dev is installed, #745356
+LIBS = $(HEIMDAL_LIB) $(LDAP_LIB) $(SSL_LIB)
+
+PROGRAMS = pwd_scheme_kinit.la
+LTVER = 0:0:0
+
+prefix=/usr/local
+exec_prefix=$(prefix)
+ldap_subdir=/openldap
+
+libdir=$(exec_prefix)/lib
+libexecdir=$(exec_prefix)/libexec
+moduledir = $(libexecdir)$(ldap_subdir)
+
+.SUFFIXES: .c .o .lo
+
+.c.lo:
+	$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(CPPFLAGS) $(DEFS) $(INCS) -c $<
+
+all: $(PROGRAMS)
+
+pwd_scheme_kinit.la:	pwd_scheme_kinit.lo
+	$(LIBTOOL) --mode=link $(CC) $(LDFLAGS) -version-info $(LTVER) \
+	-rpath $(moduledir) -module -o $@ $? $(LIBS)
+
+clean:
+	rm -rf *.o *.lo *.la .libs
+
+install: install-lib FORCE
+
+install-lib: $(PROGRAMS)
+	mkdir -p $(DESTDIR)$(moduledir)
+	for p in $(PROGRAMS) ; do \
+		$(LIBTOOL) --mode=install cp $$p $(DESTDIR)$(moduledir) ; \
+	done
+
+FORCE:
+
diff -Nuar openldap-2.4.35.orig/contrib/slapd-modules/pwd_scheme_kinit/pwd_scheme_kinit.c openldap-2.4.35/contrib/slapd-modules/pwd_scheme_kinit/pwd_scheme_kinit.c
--- openldap-2.4.35.orig/contrib/slapd-modules/pwd_scheme_kinit/pwd_scheme_kinit.c	1970-01-01 01:00:00.000000000 +0100
+++ openldap-2.4.35/contrib/slapd-modules/pwd_scheme_kinit/pwd_scheme_kinit.c	2014-02-08 12:17:51.068000000 +0100
@@ -0,0 +1,657 @@
+/* pwd_scheme_kinit.c
+ * 	OpenLDAP overlay pwd_scheme_kinit
+ *
+ * This module was derived from smbk5pwd
+ * Original upstream copyright below.
+ *
+ */
+/* 
+ *
+ * Copyright 2014-2017 Univention GmbH
+ *
+ * http://www.univention.de/
+ *
+ * All rights reserved.
+ *
+ * The source code of this program is made available
+ * under the terms of the GNU Affero General Public License version 3
+ * (GNU AGPL V3) as published by the Free Software Foundation.
+ *
+ * Binary versions of this program provided by Univention to you as
+ * well as other copyrighted, protected or trademarked materials like
+ * Logos, graphics, fonts, specific documentations and configurations,
+ * cryptographic keys etc. are subject to a license agreement between
+ * you and Univention and not subject to the GNU AGPL V3.
+ *
+ * In the case you use this program under the terms of the GNU AGPL V3,
+ * the program is provided in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public
+ * License with the Debian GNU/Linux or Univention distribution in file
+ * /usr/share/common-licenses/AGPL-3; if not, see
+ * <http://www.gnu.org/licenses/>.
+ *
+ */
+/* This work is part of OpenLDAP Software <http://www.openldap.org/>.
+ *
+ * Copyright 2004-2011 The OpenLDAP Foundation.
+ * Portions Copyright 2004-2005 by Howard Chu, Symas Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted only as authorized by the OpenLDAP
+ * Public License.
+ *
+ * A copy of this license is available in the file LICENSE in the
+ * top-level directory of the distribution or, alternatively, at
+ * <http://www.OpenLDAP.org/license.html>.
+ */
+/* ACKNOWLEDGEMENTS:
+ * Support for table-driven configuration added by Pierangelo Masarati.
+ * Support for sambaPwdMustChange and sambaPwdCanChange added by Marco D'Ettorre.
+ */
+
+#include <portable.h>
+
+#ifndef SLAPD_OVER_KRB5
+#define SLAPD_OVER_KRB5 SLAPD_MOD_DYNAMIC
+#endif
+
+#ifdef SLAPD_OVER_KRB5
+
+#include <slap.h>
+#include <ac/errno.h>
+#include <ac/string.h>
+
+#include "config.h"
+
+#include <lber.h>
+#include <lber_pvt.h>
+#include <lutil.h>
+
+/* make ASN1_MALLOC_ENCODE use our allocator */
+#define malloc	ch_malloc
+
+#include <krb5.h>
+
+static krb5_context k5_ctx;
+
+static AttributeDescription *ad_krb5PrincipalName;
+static ObjectClass *oc_krb5KDCEntry;
+
+/* Per-instance configuration information */
+typedef struct pwd_scheme_kinit_config_t {
+	unsigned	mode;
+#define	PWD_SCHEME_KINIT_FLAG_KINIT		(0x1U)
+
+#define PWD_SCHEME_KINIT_MODE_KINIT(pi)	((pi)->mode & PWD_SCHEME_KINIT_FLAG_KINIT)
+
+} pwd_scheme_kinit_config_t;
+
+static const unsigned PWD_SCHEME_KINIT_DEFAULT_FLAG	=
+	0
+#ifdef ACTIVATE_PWD_SCHEME_KINIT_BY_DEFAULT
+	| PWD_SCHEME_KINIT_FLAG_KINIT
+#endif
+;
+
+static int pwd_scheme_kinit_init( pwd_scheme_kinit_config_t *pi );
+
+static int pwd_scheme_kinit_op_cleanup(
+	Operation *op,
+	SlapReply *rs )
+{
+	slap_callback *cb;
+
+	/* clear out the current key */
+	ldap_pvt_thread_pool_setkey( op->o_threadctx, pwd_scheme_kinit_op_cleanup,
+		NULL, 0, NULL, NULL );
+
+	/* free the callback */
+	cb = op->o_callback;
+	op->o_callback = cb->sc_next;
+	op->o_tmpfree( cb, op->o_tmpmemctx );
+	return 0;
+}
+
+static int pwd_scheme_kinit_op_bind(
+	Operation *op,
+	SlapReply *rs )
+{
+	/* If this is a simple Bind, stash the Op pointer so our chk
+	 * function can find it. Set a cleanup callback to clear it
+	 * out when the Bind completes.
+	 */
+	if ( op->oq_bind.rb_method == LDAP_AUTH_SIMPLE ) {
+		slap_callback *cb;
+		ldap_pvt_thread_pool_setkey( op->o_threadctx,
+			pwd_scheme_kinit_op_cleanup, op, 0, NULL, NULL );
+		cb = op->o_tmpcalloc( 1, sizeof(slap_callback), op->o_tmpmemctx );
+		cb->sc_cleanup = pwd_scheme_kinit_op_cleanup;
+		cb->sc_next = op->o_callback;
+		op->o_callback = cb;
+	}
+	return SLAP_CB_CONTINUE;
+}
+
+static LUTIL_PASSWD_CHK_FUNC kinit_chk;
+static LUTIL_PASSWD_HASH_FUNC kinit_hash;
+static const struct berval kinit_scheme = BER_BVC("{KINIT}");
+
+static void log_k5_rc(char *custom_txt, krb5_error_code k5_rc, Operation *op)
+{
+	const char *msg;
+
+	msg = krb5_get_error_message (k5_ctx, k5_rc);
+	if (op) {
+		Debug( LDAP_DEBUG_TRACE, "%s: pwd_scheme_kinit: "
+			"%s %s\n",
+			op->o_log_prefix, custom_txt, msg );
+	} else {
+		Debug( LDAP_DEBUG_TRACE, "pwd_scheme_kinit: "
+			"%s %s\n",
+			custom_txt, msg, 0 );
+	}
+	Debug(LDAP_DEBUG_TRACE, "kerberos error code: %d", k5_rc, 0, 0);
+	krb5_free_error_message(k5_ctx, msg);
+}
+
+int verify_krb5_principal(char *principal_name, char *password, Operation *op, const char **text) {
+
+	int ret;
+
+	krb5_error_code k5_rc = 0;
+	krb5_ccache k5_cc;
+	krb5_principal k5_princ;
+	krb5_get_init_creds_opt *k5_opts;
+	krb5_creds k5_creds;
+	memset(&k5_creds, 0, sizeof(k5_creds));
+
+	/*
+	k5_rc = krb5_init_context(&k5_ctx);
+	if (k5_rc) {
+		log_k5_rc("krb5_init_context:", k5_rc, op);
+		ret = -1;
+		goto cleanup;
+	}
+	*/
+
+	k5_rc = krb5_cc_default(k5_ctx, &k5_cc);
+	if (k5_rc) {
+		log_k5_rc("krb5_cc_default:", k5_rc, op);
+		ret = -1;
+		goto cleanup;
+	}
+
+	k5_rc = krb5_parse_name(k5_ctx, principal_name, &k5_princ);
+	if (k5_rc) {
+		log_k5_rc("krb5_parse_name:", k5_rc, op);
+		ret = -1;
+		goto cleanup;
+	}
+
+	k5_rc = krb5_get_init_creds_opt_alloc(k5_ctx, &k5_opts);
+	if (k5_rc) {
+		log_k5_rc("krb5_get_init_creds_opt_alloc:", k5_rc, op);
+		ret = -1;
+		goto cleanup;
+	}
+
+	k5_rc = krb5_get_init_creds_password(k5_ctx, &k5_creds, k5_princ,
+                password, NULL, 0, 0, NULL, k5_opts);
+	// Note: this replaced the legacy krb5_get_in_tkt_with_password
+	if (k5_rc) {
+		switch(k5_rc) {
+			case KRB5KRB_AP_ERR_BAD_INTEGRITY:
+			case KRB5KRB_AP_ERR_MODIFIED:
+			case KRB5KDC_ERR_PREAUTH_FAILED:
+			case KRB5_GET_IN_TKT_LOOP:
+				/* Authentication failed */
+				if (text) *text = "The authentication has failed.";
+				break;
+			case KRB5KDC_ERR_KEY_EXP:
+				/* Authentication ok, password expired */
+				if (text) *text = "The password has expired.";
+				break;
+			case KRB5KDC_ERR_NEVER_VALID:
+				if (text) *text = "The requested effective lifetime is negative or too short.";
+				break;
+			case KRB5KRB_AP_ERR_SKEW:
+				if (text) *text = "The clock skew is too great.";
+				break;
+			case KRB5_KDC_UNREACH:
+				if (text) *text = "No authentication server is available.";
+				break;
+			default:
+				if (text) *text = "Unknown kerberos error during authentication.";
+		}
+		log_k5_rc("krb5_get_init_creds_password:", k5_rc, op);
+		ret = -1;
+		goto cleanup;
+	}
+
+	ret = 0;
+
+cleanup:
+	krb5_free_cred_contents(k5_ctx, &k5_creds);
+
+	if (k5_princ) {
+		krb5_free_principal(k5_ctx, k5_princ);
+	}
+
+	if (k5_cc) {
+		krb5_cc_close(k5_ctx, k5_cc);
+	}
+
+	return ret;
+}
+
+/* This password scheme stores no data in the userPassword attribute
+ * other than the scheme name. It assumes the invoking entry is a
+ * krb5KDCentry and performs a kinit for the krb5prinicipal of the
+ * object.
+ *
+ * Since the lutil_passwd API doesn't pass the Entry object in, we
+ * have to fetch it ourselves in order to get access to the other
+ * attributes. We accomplish this with the help of the overlay's Bind
+ * function, which stores the current Operation pointer in thread-specific
+ * storage so we can retrieve it here. The Operation provides all
+ * the necessary context for us to get Entry from the database.
+ */
+static int kinit_chk(
+	const struct berval *sc,
+	const struct berval *passwd,
+	const struct berval *cred,
+	const char **text )
+{
+	void *ldap_ctx, *op_tmp;
+	Operation *op;
+	int rc;
+	int ret = LUTIL_PASSWD_ERR;
+	Entry *e;
+	Attribute *a, *a_krb5PrincipalName;
+	char *principal;
+	char *password;
+
+	/* In this case the password is empty. This happened in one customer
+	   environment:
+	   https://forge.univention.org/bugzilla/show_bug.cgi?id=28166
+	*/
+	if ( cred->bv_len == 0 )
+		return LUTIL_PASSWD_ERR;
+
+	/* Find our thread context, find our Operation */
+	ldap_ctx = ldap_pvt_thread_pool_context();
+
+	if ( ldap_pvt_thread_pool_getkey( ldap_ctx, pwd_scheme_kinit_op_cleanup, &op_tmp, NULL )
+		 || !op_tmp ) {
+		Debug( LDAP_DEBUG_ANY, "pwd_scheme_kinit: "
+			"unable to obtain operation DN.\n",
+			0, 0, 0 );
+		return LUTIL_PASSWD_ERR;
+	}
+	op = op_tmp;
+
+	rc = be_entry_get_rw( op, &op->o_req_ndn, NULL, NULL, 0, &e );
+	if ( rc != LDAP_SUCCESS ) {
+		Debug( LDAP_DEBUG_ANY, "pwd_scheme_kinit: "
+			"unable to get entry for DN: %s\n",
+			BER_BVISNULL( &op->o_req_ndn ) ? "(null)" : op->o_req_ndn.bv_val, 0, 0 );
+		return LUTIL_PASSWD_ERR;
+	}
+
+	a_krb5PrincipalName = attr_find( e->e_attrs, ad_krb5PrincipalName );
+	if (!a_krb5PrincipalName ) {
+		Debug( LDAP_DEBUG_ANY, "pwd_scheme_kinit: "
+			"unable to find \"krb5PrincipalName\" attribute on %s.\n",
+			op->o_req_ndn.bv_val, 0, 0 );
+		ret = LUTIL_PASSWD_ERR;
+		goto done;
+	}
+
+	// bv_val isn't guaranteed to be a terminated string
+	principal = ch_malloc(a_krb5PrincipalName->a_vals[0].bv_len + 1);
+	memcpy( principal, a_krb5PrincipalName->a_vals[0].bv_val, a_krb5PrincipalName->a_vals[0].bv_len );
+	principal[a_krb5PrincipalName->a_vals[0].bv_len] = '\0';
+	
+	password = ch_malloc(cred->bv_len + 1);
+	memcpy( password, cred->bv_val, cred->bv_len );
+	password[cred->bv_len] = '\0';
+
+	rc = verify_krb5_principal(principal, password, op, text);
+	if ( rc ) {
+		ret = LUTIL_PASSWD_ERR;
+		goto done;
+	}
+
+	ret = LUTIL_PASSWD_OK;
+
+done:
+	be_entry_release_r( op, e );
+	ch_free(principal);
+	memset(password, 0, cred->bv_len);
+	ch_free(password);
+	return ret;
+}
+
+static int kinit_hash(
+	const struct berval *scheme,
+	const struct berval *passwd,
+	struct berval *hash,
+	const char **text )
+{
+	ber_dupbv( hash, (struct berval *)&kinit_scheme );
+	return LUTIL_PASSWD_OK;
+}
+
+/* TODO: This looks like a bv_val termination hack, but is bv_val long enough? What is the purpose here?
+ *
+static int pwd_scheme_kinit_exop_passwd(
+	Operation *op,
+	SlapReply *rs )
+{
+	int rc;
+	req_pwdexop_s *qpw = &op->oq_pwdexop;
+	Entry *e;
+	Modifications *ml;
+	slap_overinst *on = (slap_overinst *)op->o_bd->bd_info;
+	pwd_scheme_kinit_config_t *pi = on->on_bi.bi_private;
+	char term;
+
+	// Not the operation we expected, pass it on...
+	if ( ber_bvcmp( &slap_EXOP_MODIFY_PASSWD, &op->ore_reqoid ) ) {
+		return SLAP_CB_CONTINUE;
+	}
+
+	op->o_bd->bd_info = (BackendInfo *)on->on_info;
+	rc = be_entry_get_rw( op, &op->o_req_ndn, NULL, NULL, 0, &e );
+	if ( rc != LDAP_SUCCESS ) return rc;
+
+	term = qpw->rs_new.bv_val[qpw->rs_new.bv_len];
+	qpw->rs_new.bv_val[qpw->rs_new.bv_len] = '\0';
+
+	be_entry_release_r( op, e );
+	qpw->rs_new.bv_val[qpw->rs_new.bv_len] = term;
+
+	return SLAP_CB_CONTINUE;
+}
+*/
+
+/* back-config stuff */
+enum {
+	PC_PWDSKINIT_ENABLE = 1,	// refers to order in the ConfigTable below
+};
+
+static ConfigDriver pwd_scheme_kinit_cf_func;
+
+/*
+ * NOTE: uses OID arcs OLcfgCtAt:2 and OLcfgCtOc:2
+ */
+
+static ConfigTable pwd_scheme_kinit_cfats[] = {
+	{ "pwdskinit-enable", "arg",
+		2, 0, 0, ARG_MAGIC|PC_PWDSKINIT_ENABLE, pwd_scheme_kinit_cf_func,
+		"( OLcfgCtAt:2.1 NAME 'olcPwdsKinitEnable' "
+		"DESC 'Modules to be enabled' "
+		"SYNTAX OMsDirectoryString )", NULL, NULL },
+
+	{ NULL, NULL, 0, 0, 0, ARG_IGNORED }
+};
+
+static ConfigOCs pwd_scheme_kinit_cfocs[] = {
+	{ "( OLcfgCtOc:2.1 "
+		"NAME 'olcPwdsKinitConfig' "
+		"DESC 'Pwd scheme kinit overlay configuration' "
+		"SUP olcOverlayConfig "
+		"MAY ( "
+			"olcPwdsKinitEnable "
+		") )", Cft_Overlay, pwd_scheme_kinit_cfats },
+
+	{ NULL, 0, NULL }
+};
+
+/*
+ * add here other functionalities; handle their initialization
+ * as appropriate in pwd_scheme_kinit_init().
+ */
+static slap_verbmasks pwd_scheme_kinit_modes[] = {
+	{ BER_BVC( "kinit" ),		PWD_SCHEME_KINIT_FLAG_KINIT	},
+	{ BER_BVNULL,			-1 }
+};
+
+static int
+pwd_scheme_kinit_cf_func( ConfigArgs *c )
+{
+	slap_overinst	*on = (slap_overinst *)c->bi;
+
+	int		rc = 0;
+	pwd_scheme_kinit_config_t	*pi = on->on_bi.bi_private;
+
+	if ( c->op == SLAP_CONFIG_EMIT ) {
+		switch( c->type ) {
+			case PC_PWDSKINIT_ENABLE:
+				c->rvalue_vals = NULL;
+				if ( pi->mode ) {
+					mask_to_verbs( pwd_scheme_kinit_modes, pi->mode, &c->rvalue_vals );
+					if ( c->rvalue_vals == NULL ) {
+						rc = 1;
+					}
+				}
+				break;
+
+			default:
+				assert( 0 );
+				rc = 1;
+		}
+		return rc;
+
+	} else if ( c->op == LDAP_MOD_DELETE ) {
+		switch( c->type ) {
+			case PC_PWDSKINIT_ENABLE:
+				if ( !c->line ) {
+					pi->mode = 0;
+
+				} else {
+					slap_mask_t	m;
+
+					m = verb_to_mask( c->line, pwd_scheme_kinit_modes );
+					pi->mode &= ~m;
+				}
+				break;
+
+			default:
+				assert( 0 );
+				rc = 1;
+		}
+		return rc;
+	}
+
+	switch( c->type ) {
+		case PC_PWDSKINIT_ENABLE: {
+			slap_mask_t	mode = pi->mode, m;
+
+			rc = verbs_to_mask( c->argc, c->argv, pwd_scheme_kinit_modes, &m );
+			if ( rc > 0 ) {
+				Debug( LDAP_DEBUG_ANY, "%s: pwd_scheme_kinit: "
+					"<%s> unknown module \"%s\".\n",
+					c->log, c->argv[ 0 ], c->argv[ rc ] );
+				return 1;
+			}
+
+			/* we can hijack the pwd_scheme_kinit_config_t structure because
+			* from within the configuration, this is the only
+			* active thread. */
+			pi->mode |= m;
+
+
+			{
+				BackendDB	db = *c->be;
+
+				/* Re-initialize the module, because
+				* the configuration might have changed */
+				db.bd_info = (BackendInfo *)on;
+				rc = pwd_scheme_kinit_init( pi );
+				if ( rc ) {
+					pi->mode = mode;
+					return 1;
+				}
+			}
+
+			} break;
+
+		default:
+			assert( 0 );
+			return 1;
+	}
+	return rc;
+}
+
+static int
+pwd_scheme_kinit_init( pwd_scheme_kinit_config_t *pi )
+{
+	static struct {
+		const char		*name;
+		AttributeDescription	**adp;
+	}
+	krb5_ad[] = {
+		{ "krb5PrincipalName",		&ad_krb5PrincipalName },
+		{ NULL }
+	},
+	dummy_ad;
+
+	/* this is to silence the unused var warning */
+	dummy_ad.name = NULL;
+
+	if ( PWD_SCHEME_KINIT_MODE_KINIT( pi ) && oc_krb5KDCEntry == NULL ) {
+		krb5_error_code	k5_rc;
+
+		int		i, rc;
+
+		/* Make sure all of our necessary schema items are loaded */
+		oc_krb5KDCEntry = oc_find( "krb5KDCEntry" );
+		if ( !oc_krb5KDCEntry ) {
+			Debug( LDAP_DEBUG_ANY, "pwd_scheme_kinit: "
+				"unable to find \"krb5KDCEntry\" objectClass.\n",
+				0, 0, 0 );
+			return -1;
+		}
+
+		for ( i = 0; krb5_ad[ i ].name != NULL; i++ ) {
+			const char	*text;
+
+			*(krb5_ad[ i ].adp) = NULL;
+
+			rc = slap_str2ad( krb5_ad[ i ].name, krb5_ad[ i ].adp, &text );
+			if ( rc != LDAP_SUCCESS ) {
+				Debug( LDAP_DEBUG_ANY, "pwd_scheme_kinit: "
+					"unable to find \"%s\" attributeType: %s (%d).\n",
+					krb5_ad[ i ].name, text, rc );
+				oc_krb5KDCEntry = NULL;
+				return rc;
+			}
+		}
+
+		/* Initialize Kerberos context */
+		k5_rc = krb5_init_context(&k5_ctx);
+		if (k5_rc) {
+			log_k5_rc("unable to initialize krb5 context", k5_rc, NULL);
+			return -1;
+		}
+
+	}
+
+	return 0;
+}
+
+static int
+pwd_scheme_kinit_db_init(BackendDB *be, ConfigReply *cr)
+{
+	slap_overinst	*on = (slap_overinst *)be->bd_info;
+	pwd_scheme_kinit_config_t	*pi;
+
+	pi = ch_calloc( 1, sizeof( pwd_scheme_kinit_config_t ) );
+	if ( pi == NULL ) {
+		return 1;
+	}
+	on->on_bi.bi_private = (void *)pi;
+
+	return 0;
+}
+
+static int
+pwd_scheme_kinit_db_open(BackendDB *be, ConfigReply *cr)
+{
+	slap_overinst	*on = (slap_overinst *)be->bd_info;
+	pwd_scheme_kinit_config_t	*pi = \
+		(pwd_scheme_kinit_config_t *)on->on_bi.bi_private;
+
+	int	rc;
+
+	if ( pi->mode == 0 ) {
+		pi->mode = PWD_SCHEME_KINIT_DEFAULT_FLAG;
+	}
+
+	rc = pwd_scheme_kinit_init( pi );
+	if ( rc ) {
+		return rc;
+	}
+
+	return 0;
+}
+
+static int
+pwd_scheme_kinit_db_destroy(BackendDB *be, ConfigReply *cr)
+{
+	slap_overinst	*on = (slap_overinst *)be->bd_info;
+	pwd_scheme_kinit_config_t	*pi = (pwd_scheme_kinit_config_t *)on->on_bi.bi_private;
+
+	if (k5_ctx) {
+		krb5_free_context( k5_ctx );
+	}
+
+	if ( pi ) {
+		ch_free( pi );
+	}
+
+	return 0;
+}
+
+static slap_overinst pwd_scheme_kinit;
+
+int
+pwd_scheme_kinit_initialize(void)
+{
+	int		rc;
+
+	pwd_scheme_kinit.on_bi.bi_type = "pwd_scheme_kinit";
+
+	pwd_scheme_kinit.on_bi.bi_db_init = pwd_scheme_kinit_db_init;
+	pwd_scheme_kinit.on_bi.bi_db_open = pwd_scheme_kinit_db_open;
+	pwd_scheme_kinit.on_bi.bi_db_destroy = pwd_scheme_kinit_db_destroy;
+
+	// pwd_scheme_kinit.on_bi.bi_extended = pwd_scheme_kinit_exop_passwd;
+    
+	pwd_scheme_kinit.on_bi.bi_op_bind = pwd_scheme_kinit_op_bind;
+
+	lutil_passwd_add( (struct berval *)&kinit_scheme, kinit_chk, kinit_hash );
+
+	pwd_scheme_kinit.on_bi.bi_cf_ocs = pwd_scheme_kinit_cfocs;
+
+	rc = config_register_schema( pwd_scheme_kinit_cfats, pwd_scheme_kinit_cfocs );
+	if ( rc ) {
+		return rc;
+	}
+
+	return overlay_register( &pwd_scheme_kinit );
+}
+
+#if SLAPD_OVER_KRB5 == SLAPD_MOD_DYNAMIC
+int init_module(int argc, char *argv[]) {
+	return pwd_scheme_kinit_initialize();
+}
+#endif
+
+#endif /* defined(SLAPD_OVER_KRB5) */
